<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D 街中ラン</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; font-family: "Hiragino Sans", "Yu Gothic UI", sans-serif; }
    canvas { display: block; }

    #ui {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      padding: 16px 24px;
      pointer-events: none;
      z-index: 10;
    }

    .energy-wrap {
      max-width: 280px;
    }
    .energy-label {
      color: rgba(255,255,255,0.9);
      font-size: 12px;
      letter-spacing: 0.1em;
      margin-bottom: 4px;
    }
    .energy-bar-bg {
      height: 14px;
      background: rgba(0,0,0,0.5);
      border-radius: 7px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.2);
    }
    .energy-bar {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, #4ade80, #22c55e);
      border-radius: 6px;
      transition: width 0.15s ease;
    }
    .energy-bar.low { background: linear-gradient(90deg, #fbbf24, #f59e0b); }
    .energy-bar.critical { background: linear-gradient(90deg, #ef4444, #dc2626); }

    .hint {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.6);
      font-size: 13px;
      letter-spacing: 0.1em;
      pointer-events: none;
      z-index: 10;
    }

    .direction-meter {
      position: fixed;
      bottom: 56px;
      right: 24px;
      width: 72px;
      height: 72px;
      border-radius: 50%;
      background: rgba(0,0,0,0.4);
      border: 2px solid rgba(255,255,255,0.35);
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 10;
    }
    .direction-meter .needle {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 4px;
      height: 26px;
      margin-left: -2px;
      margin-top: -26px;
      background: linear-gradient(to top, rgba(255,255,255,0.3), #fff);
      border-radius: 2px;
      transform-origin: 2px 26px;
      box-shadow: 0 0 8px rgba(255,255,255,0.4);
    }
    .direction-meter .labels {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 9px;
      color: rgba(255,255,255,0.7);
      font-weight: bold;
      letter-spacing: 0.05em;
    }
    .direction-meter .n { top: 4px; left: 50%; transform: translateX(-50%); position: absolute; }
    .direction-meter .e { right: 6px; top: 50%; transform: translateY(-50%); position: absolute; }
    .direction-meter .s { bottom: 4px; left: 50%; transform: translateX(-50%); position: absolute; }
    .direction-meter .w { left: 6px; top: 50%; transform: translateY(-50%); position: absolute; }

    .speed-meter {
      position: fixed;
      bottom: 56px;
      right: 106px;
      width: 72px;
      height: 44px;
      border-radius: 8px;
      background: rgba(0,0,0,0.4);
      border: 2px solid rgba(255,255,255,0.35);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 10;
    }
    .speed-meter .label {
      font-size: 9px;
      color: rgba(255,255,255,0.7);
      letter-spacing: 0.1em;
      margin-bottom: 2px;
    }
    .speed-meter .value {
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      font-variant-numeric: tabular-nums;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    .speed-meter .unit {
      font-size: 10px;
      color: rgba(255,255,255,0.6);
      margin-left: 2px;
    }
    .speed-meter .gauge {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: rgba(0,0,0,0.3);
      border-radius: 0 0 6px 6px;
      overflow: hidden;
    }
    .speed-meter .gauge-fill {
      height: 100%;
      background: linear-gradient(90deg, #22c55e, #4ade80);
      border-radius: 0 0 4px 4px;
      transition: width 0.08s ease-out;
    }

    .alt-meter {
      position: fixed;
      bottom: 56px;
      right: 184px;
      width: 72px;
      height: 44px;
      border-radius: 8px;
      background: rgba(0,0,0,0.4);
      border: 2px solid rgba(255,255,255,0.35);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 10;
    }
    .alt-meter .label {
      font-size: 9px;
      color: rgba(255,255,255,0.7);
      letter-spacing: 0.1em;
      margin-bottom: 2px;
    }
    .alt-meter .value {
      font-size: 20px;
      font-weight: bold;
      color: #fff;
      font-variant-numeric: tabular-nums;
      text-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    .alt-meter .unit {
      font-size: 10px;
      color: rgba(255,255,255,0.6);
      margin-left: 2px;
    }
    .alt-meter .gauge {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 6px;
      background: rgba(0,0,0,0.3);
      border-radius: 0 0 6px 6px;
      overflow: hidden;
    }
    .alt-meter .gauge-fill {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #60a5fa);
      border-radius: 0 0 4px 4px;
      transition: width 0.08s ease-out;
    }
  </style>
</head>
<body>
  <div id="ui">
    <div class="energy-wrap">
      <div class="energy-label">エネルギー</div>
      <div class="energy-bar-bg">
        <div class="energy-bar" id="energyBar"></div>
      </div>
    </div>
  </div>
  <div class="alt-meter" aria-hidden="true">
    <span class="label">ALT</span>
    <div>
      <span class="value" id="altValue">0</span><span class="unit">m</span>
    </div>
    <div class="gauge">
      <div class="gauge-fill" id="altGauge"></div>
    </div>
  </div>
  <div class="speed-meter" aria-hidden="true">
    <span class="label">SPEED</span>
    <div>
      <span class="value" id="speedValue">0</span><span class="unit">m/s</span>
    </div>
    <div class="gauge">
      <div class="gauge-fill" id="speedGauge"></div>
    </div>
  </div>
  <div class="direction-meter" aria-hidden="true">
    <div class="labels">
      <span class="n">N</span><span class="e">E</span><span class="s">S</span><span class="w">W</span>
    </div>
    <div class="needle" id="directionNeedle"></div>
  </div>
  <p class="hint">A/D: 旋回　W/S: 加速・減速（消費）　Q/E: 上下　食べ物で回復</p>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    scene.fog = new THREE.Fog(0x87ceeb, 80, 250);

    const ambient = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambient);
    const sun = new THREE.DirectionalLight(0xffffff, 1);
    sun.position.set(50, 100, 50);
    sun.castShadow = true;
    sun.shadow.mapSize.width = 2048;
    sun.shadow.mapSize.height = 2048;
    sun.shadow.camera.near = 0.5;
    sun.shadow.camera.far = 300;
    sun.shadow.camera.left = -80;
    sun.shadow.camera.right = 80;
    sun.shadow.camera.top = 80;
    sun.shadow.camera.bottom = -80;
    scene.add(sun);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 500);
    camera.position.set(0, 1.6, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.body.appendChild(renderer.domElement);

    const groundGeo = new THREE.PlaneGeometry(500, 500);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0x4a5568 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    const cityRoot = new THREE.Group();
    scene.add(cityRoot);

    const collisionBoxes = [];

    function createProceduralCity() {
      collisionBoxes.length = 0;
      const blockSize = 8;
      const gridHalf = 25;
      const buildingMat = new THREE.MeshStandardMaterial({ color: 0x64748b });
      const buildingMatDark = new THREE.MeshStandardMaterial({ color: 0x475569 });

      for (let gx = -gridHalf; gx <= gridHalf; gx++) {
        for (let gz = -gridHalf; gz <= gridHalf; gz++) {
          if (Math.random() < 0.3) continue;
          const wx = gx * blockSize + (Math.random() - 0.5) * blockSize * 0.5;
          const wz = gz * blockSize + (Math.random() - 0.5) * blockSize * 0.5;
          const w = 4 + Math.random() * 6;
          const d = 4 + Math.random() * 6;
          const h = 6 + Math.random() * 30;
          const box = new THREE.BoxGeometry(w, h, d);
          const mat = Math.random() > 0.5 ? buildingMat : buildingMatDark;
          const mesh = new THREE.Mesh(box, mat);
          mesh.position.set(wx, h / 2, wz);
          mesh.castShadow = true;
          mesh.receiveShadow = true;
          cityRoot.add(mesh);
          collisionBoxes.push({
            minX: wx - w / 2, maxX: wx + w / 2,
            minY: 0, maxY: h,
            minZ: wz - d / 2, maxZ: wz + d / 2
          });
        }
      }
      const cx = (b) => (b.minX + b.maxX) / 2;
      const cz = (b) => (b.minZ + b.maxZ) / 2;
      let start = collisionBoxes[0];
      let bestD2 = Infinity;
      for (const b of collisionBoxes) {
        const dx = cx(b), dz = cz(b);
        const d2 = dx * dx + dz * dz;
        if (d2 < bestD2) { bestD2 = d2; start = b; }
      }
      const startX = (start.minX + start.maxX) / 2;
      const startZ = (start.minZ + start.maxZ) / 2;
      camera.position.set(startX, start.maxY + 1.6, startZ);
    }

    // PLATEAUのglTFを使う場合: BlenderでFBX/OBJ→glTF変換後、gltf/city.glb に配置するかパスを変更
    const PLATEAU_GLTF_PATH = 'gltf/city.glb';
    let plateauLoaded = false;

    function tryLoadPLATEAU() {
      const loader = new GLTFLoader();
      loader.load(
        PLATEAU_GLTF_PATH,
        (gltf) => {
          const model = gltf.scene;
          model.traverse((c) => {
            if (c.isMesh) {
              c.castShadow = true;
              c.receiveShadow = true;
            }
          });
          model.scale.setScalar(1);
          model.position.set(0, 0, 0);
          cityRoot.add(model);
          plateauLoaded = true;
        },
        undefined,
        () => { createProceduralCity(); }
      );
    }

    tryLoadPLATEAU();

    const foods = [];
    const foodGeo = new THREE.SphereGeometry(0.4, 12, 12);
    const foodMat = new THREE.MeshStandardMaterial({ color: 0xfbbf24 });
    const collectRadius = 2.5;
    const energyPerFood = 25;

    function addFood(x, z) {
      const mesh = new THREE.Mesh(foodGeo, foodMat.clone());
      mesh.position.set(x, 0.6, z);
      mesh.castShadow = true;
      scene.add(mesh);
      foods.push({ mesh, x, z, collected: false });
    }

    for (let i = 0; i < 60; i++) {
      const x = (Math.random() - 0.5) * 200;
      const z = (Math.random() - 0.5) * 200;
      addFood(x, z);
    }

    let yaw = 0;
    const baseSpeed = 18;
    let speedMultiplier = 1;
    const turnSpeed = 1.8;
    const energyCostPerSec = 15;
    let energy = 100;
    const clock = new THREE.Clock();

    const keys = { w: false, a: false, s: false, d: false, q: false, e: false };
    const verticalSpeed = 12;
    const minHeight = 1.6;
    const maxHeight = 80;
    const playerRadius = 0.5;

    document.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (k === 'w') keys.w = true;
      if (k === 'a') keys.a = true;
      if (k === 's') keys.s = true;
      if (k === 'd') keys.d = true;
      if (k === 'q') keys.q = true;
      if (k === 'e') keys.e = true;
      if (['w','a','s','d','q','e'].includes(k)) e.preventDefault();
    });
    document.addEventListener('keyup', (e) => {
      const k = e.key.toLowerCase();
      if (k === 'w') keys.w = false;
      if (k === 'a') keys.a = false;
      if (k === 's') keys.s = false;
      if (k === 'd') keys.d = false;
      if (k === 'q') keys.q = false;
      if (k === 'e') keys.e = false;
    });

    function clampToAABB(p, box, r) {
      const cx = Math.max(box.minX, Math.min(box.maxX, p.x));
      const cy = Math.max(box.minY, Math.min(box.maxY, p.y));
      const cz = Math.max(box.minZ, Math.min(box.maxZ, p.z));
      const dx = p.x - cx, dy = p.y - cy, dz = p.z - cz;
      const d2 = dx * dx + dy * dy + dz * dz;
      if (d2 === 0) return;
      if (d2 >= r * r) return;
      const d = Math.sqrt(d2);
      const push = r - d;
      p.x += (dx / d) * push;
      p.y += (dy / d) * push;
      p.z += (dz / d) * push;
    }

    function resolveCollisions() {
      const p = camera.position;
      if (p.y < minHeight) p.y = minHeight;
      if (p.y > maxHeight) p.y = maxHeight;
      for (let iter = 0; iter < 3; iter++) {
        for (let i = 0; i < collisionBoxes.length; i++) {
          clampToAABB(p, collisionBoxes[i], playerRadius);
        }
        if (p.y < minHeight) p.y = minHeight;
      }
    }

    function updateEnergyBar() {
      const el = document.getElementById('energyBar');
      el.style.width = Math.max(0, energy) + '%';
      el.classList.remove('low', 'critical');
      if (energy < 25) el.classList.add('critical');
      else if (energy < 50) el.classList.add('low');
    }

    function updateDirectionMeter() {
      const needle = document.getElementById('directionNeedle');
      if (!needle) return;
      const deg = -yaw * (180 / Math.PI);
      needle.style.transform = `rotate(${deg}deg)`;
    }

    const maxSpeed = baseSpeed * 1.6;
    function updateSpeedMeter() {
      const speed = baseSpeed * speedMultiplier;
      const el = document.getElementById('speedValue');
      const gauge = document.getElementById('speedGauge');
      if (el) el.textContent = Math.round(speed);
      if (gauge) gauge.style.width = Math.min(100, (speed / maxSpeed) * 100) + '%';
    }

    function updateAltitudeMeter() {
      const alt = camera.position.y;
      const el = document.getElementById('altValue');
      const gauge = document.getElementById('altGauge');
      if (el) el.textContent = Math.round(alt);
      if (gauge) {
        const pct = Math.min(100, ((alt - minHeight) / (maxHeight - minHeight)) * 100);
        gauge.style.width = Math.max(0, pct) + '%';
      }
    }

    function animate() {
      requestAnimationFrame(animate);
      const dt = Math.min(clock.getDelta(), 0.1);

      if (keys.a) yaw += turnSpeed * dt;
      if (keys.d) yaw -= turnSpeed * dt;

      camera.rotation.order = 'YXZ';
      camera.rotation.y = yaw;
      camera.rotation.x = 0;
      camera.rotation.z = 0;

      const forward = new THREE.Vector3();
      camera.getWorldDirection(forward);
      forward.y = 0;
      if (forward.lengthSq() > 0.0001) forward.normalize();

      speedMultiplier = 1;
      if (keys.w && energy > 0) {
        speedMultiplier = 1.6;
        energy = Math.max(0, energy - energyCostPerSec * dt);
      }
      if (keys.s && energy > 0) {
        speedMultiplier = 0.5;
        energy = Math.max(0, energy - energyCostPerSec * dt);
      }

      const move = forward.multiplyScalar(baseSpeed * speedMultiplier * dt);
      camera.position.add(move);

      if (keys.q) camera.position.y += verticalSpeed * dt;
      if (keys.e) camera.position.y -= verticalSpeed * dt;
      resolveCollisions();

      foods.forEach((f) => {
        if (f.collected) return;
        const dx = camera.position.x - f.x;
        const dz = camera.position.z - f.z;
        if (dx * dx + dz * dz < collectRadius * collectRadius) {
          f.collected = true;
          f.mesh.visible = false;
          energy = Math.min(100, energy + energyPerFood);
        }
      });

      updateEnergyBar();
      updateAltitudeMeter();
      updateSpeedMeter();
      updateDirectionMeter();
      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
